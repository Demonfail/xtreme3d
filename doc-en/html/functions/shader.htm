<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Shaders</TITLE>
<META content="text/html; charset=utf-8" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css href="../data/style.css">
<META name=GENERATOR content="MSHTML 8.00.6001.23536"></HEAD>
<BODY>
<DIV align=justify>
<H1 class=pagetitle>Shaders </H1><A class=type>Class: TGLShader, TGLCelShader, 
TGLMultiMaterialShader, TGLHiddenLineShader, TGLOutlineShader, 
TGLTexCombineShader, TGLSLShader</A><BR><BR><A>The SHADER Xtreme3D is for 
special material. There are several types of shaders: Bump, The Cel, The 
HiddenLine, MultiMaterial, Outline, The TexCombine, Phong and the GLSL. For the 
application of the shader to the material uses the </A><A class=funclink 
href="../functions/material.htm#MaterialSetShader">MaterialSetShader</A><A>. 
Using the shaders in the language of the GLSL you can program their own special 
effects. <BR>
<HR>
<A name=ShaderEnable></A>
<H1 class=name>ShaderEnable </H1><A class=type>Real</A><A> </A><A 
class=function>ShaderEnable =</A><A>( shader,mode as </A><A 
class=type>real</A><A> );</A> <BR><A>Enables or disables the shader.</A> 
<BR><A>Shader - Shader id</A> <BR><A>Mode - </A><A class=constant>true</A><A> or 
</A><A class=constant>false</A><A> (1 and 0, respectively).</A> 
<HR>
<A name=BumpShaderCreate></A>
<H1 class=name>BumpShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderCreate =</A><A>( );</A> <BR><A>Creates the terrain 
shader (bump mapping) and returns its id. With it, you can achieve a very 
spectacular imitation of bumps on the surface of the model. <BR>This shader 
requires the support of the extensions of GL_ARB_shading_language (or 
GL_ARB_shading_language_100), GL_ARB_shader_objects, GL_ARB__vertex shader, 
GL_ARB_fragment_shader.</A> 
<HR>
<A name=BumpShaderSetDiffuseTexture></A>
<H1 class=name>BumpShaderSetDiffuseTexture </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderSetDiffuseTexture =</A><A>( shader as </A><A 
class=type>real</A><A>, material as </A><A class=type>string</A><A> );</A> 
<BR><A>Specifies the ��������� shader texture of the terrain. The diffuse 
texture - this is the usual texture, which determines the color of the surface 
of the object, as well as transparency, if it has the alpha channel).</A> 
<BR><A>Shader - Shader id</A> <BR><A>The material is the name of the material in 
the current library, which should be read in texture. If instead of the name 
specified the empty string, it will be used by the texture of the material, 
connected to the shader (texture in slot 0). Thus, one and the same shader can 
work with different textures depending on the material that, in some situations, 
it is very convenient.</A> 
<HR>
<A name=BumpShaderSetNormalTexture></A>
<H1 class=name>BumpShaderSetNormalTexture </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderSetNormalTexture =</A><A>( shader as </A><A 
class=type>real</A><A>, material as </A><A class=type>string</A><A> );</A> 
<BR><A>Specifies the normal map terrain shader. Normal Map is a texture that 
defines normal at each point on the surface of the object (XYZ RGB =). 
BumpShader supports normal maps in the space of the tangent (tangent space) - 
that is defined in the space where the Z-axis corresponds to the normal 
interpolated triangle, and X and Y are mutually perpendicular to the tangents to 
the normal (also called the tangent bitangent and).</A> <BR><A>Shader - Shader 
id</A> <BR><A>The material is the name of the material in the current library, 
which should be read in texture. If instead of the name specified the empty 
string, it will be used by the second texture of the material, connected to the 
shader texture (slot 1). Thus, one and the same shader can work with different 
textures depending on the material that, in some situations, it is very 
convenient.</A> 
<HR>
<A name=BumpShaderSetHeightTexture></A>
<H1 class=name>BumpShaderSetHeightTexture </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderSetHeightTexture =</A><A>( shader as </A><A 
class=type>real</A><A>, material as </A><A class=type>string</A><A> );</A> 
<BR><A>Specifies the map shader heights of terrain. Map of heights - this is the 
texture, dark elements of which means reduced height and bright - increase. Map 
of the heights is necessary when using the effect of parallax mapping (see 
below). If this effect is disabled, the map heights is not required.</A> 
<BR><A>Shader - Shader id</A> <BR><A>The material is the name of the material in 
the current library, which should be read in texture. If instead of the name 
specified the empty string, it will be used by the third texture of the 
material, connected to the shader (texture in slot 2). Thus, one and the same 
shader can work with different textures depending on the material that, in some 
situations, it is very convenient.</A> 
<HR>
<A name=BumpShaderUseParallax></A>
<H1 class=name>BumpShaderUseParallax </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderUseParallax =</A><A>( shader,mode as </A><A 
class=type>real</A><A> );</A> <BR><A>Enables or disables the parallax mapping - 
The effect of enhancing the illusion of relief, achieved at the expense of 
displacement texture coordinates depending on the angle of view. This effect 
requires the guidance cards heights </A><A class=funclink 
href="../functions/shader.htm#BumpShaderSetHeightTexture">BumpShaderSetHeightTexture 
function<A><A>.</A> <BR><A>Shader - Shader id</A> <BR><A>Mode - </A><A 
class=constant>true</A><A> or </A><A class=constant>false</A><A> (1 and 0, 
respectively). By default, the parallax mapping is turned off.</A> 
<HR>
<A name=BumpShaderSetParallaxOffset></A>
<H1 class=name>BumpShaderSetParallaxOffset </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderSetParallaxOffset =</A><A>( shader,offset as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the factor to offset the effect 
of parallax mapping. The larger the value, the higher the relief.</A> 
<BR><A>Shader - Shader id</A> <BR><A>Offset - the offset. The default value is 
0.03.</A> 
<HR>
<A name=BumpShaderSetMaxLights></A>
<H1 class=name>BumpShaderSetMaxLights </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderSetMaxLights =</A><A>( shader,maxlights as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the number of light sources, 
which should be taken into account terrain shader. This number, as a rule, is 
less than or equal to the number of light sources created by the function of the 
</A><A class=funclink 
href="../functions/light.htm#LightCreate">LightCreate</A><A>. Accordingly, it is 
limited to eight - the maximum number of built-in light sources OpenGL. Shader 
supports all types of light sources: </A><A class=constant>lsOmni</A><A>, </A><A 
class=constant>lsSpot</A><A>, </A><A class=constant>lsParallel</A><A>. <BR>Note 
also that the condition of the inclusion/������������� light sources, which is 
selected by the function of the </A><A class=funclink 
href="../functions/light.htm#LightSetShining">LightSetShining</A><A>ignores the 
shader. To turn off the light source that can </A><A class=funclink 
href="../functions/light.htm#LightSetAttenuation"></A><A>adjust 
LightSetAttenuation to zero his constant component of the attenuation constant 
attenuation). </A><BR><A>Shader - Shader id</A> <BR><A>Maxlights - the number of 
light sources. The default value is: 1.</A> 
<HR>
<A name=BumpShaderSetShadowMap></A>
<H1 class=name>BumpShaderSetShadowMap </H1><A class=type>Real</A><A> </A><A 
class=function>BumpShaderSetShadowMap =</A><A>( shader,shadowmap as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the shadow card, which terrain 
shader to use for drawing shadows. By default, the shadow map is not assigned 
and not shader renders the shadow.</A> <BR><A>Shader - Shader id</A> 
<BR><A>Shadowmap - id of the shadow map. If this parameter to 0, the shadow will 
be disabled.</A> 
<HR>
<A name=BumpShaderSetShadowBlurRadius></A>
<H1 class=name>BumpShaderSetShadowBlurRadius </H1><A class=type>Real</A><A> 
</A><A class=function>BumpShaderSetShadowBlurRadius =</A><A>( shader radius,as 
</A><A class=type>real</A><A> );</A> <BR><A>If the terrain shader assigned a 
shadow map, this function specifies the radius of the PCF filtration of the 
shadow map - as a result, obtained the soft shadows.</A> <BR><A>Shader - Shader 
id</A> <BR><A>Radius - The radius of blur. A value of 0 means that there is no 
filtration (the shadow will be sharp). It is recommended to set the radius 
values from 1 to 3 - higher values can reduce performance. The default value is 
0.</A> 
<HR>
<A name=BumpShaderUseAutoTangentSpace></A>
<H1 class=name>BumpShaderUseAutoTangentSpace </H1><A class=type>Real</A><A> 
</A><A class=function>BumpShaderUseAutoTangentSpace =</A><A>( shader,mode as 
</A><A class=type>real</A><A> );</A> <BR><A>Some of the objects of Xtreme3D does 
not provide �������� information on the space of the tangent to the terrain 
rendering is the actors and the built-in entities. This feature solves this 
problem: it enables or disables the automatic generation of ������������ vector 
and The ��������� ����������� �������. The result is a somewhat less qualitative 
than using a fully ���������������� vectors - with a strong approximation of 
visible edges of polygons, but it depends on whether there are discontinuities 
(seams) in texture coordinates of the model. If the UV scan continuous as the 
primitives, the ribs visibly will not be.</A> <BR><A>To enable this option, so 
that the model were texture coordinates.</A> <BR><A>Shader - Shader id</A> 
<BR><A>Mode - </A><A class=constant>true</A><A> or </A><A 
class=constant>false</A><A> (1 and 0, respectively). By default, the option is 
disabled.</A> 
<HR>
<A name=CelShaderCreate></A>
<H1 class=name>CelShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>CelShaderCreate =</A><A>();</A> <BR><A>Creates a so-called 
cel-shader and returns its id. This type of shader is used to create the special 
effect of animated images. It includes the drawing of contours and 
simplification of the lighting models (light and shade are clearly defined 
spots). <BR>This shader requires the support of the extensions of 
GL_ARB_vertex_program and GL_ARB_fragment_program.</A></A> 
<HR>
<A name=CelShaderSetLineColor></A>
<H1 class=name>CelShaderSetLineColor </H1><A class=type>Real</A><A> </A><A 
class=function>CelShaderSetLineColor =</A><A>( shader,color as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the color of the contour in the 
cel-�������.</A> <BR><A>Shader - Shader id</A> <BR><A>Color - the color.</A> 
<HR>
<A name=CelShaderSetLineWidth></A>
<H1 class=name>CelShaderSetLineWidth </H1><A class=type>Real</A><A> </A><A 
class=function>CelShaderSetLineWidth =</A><A>( shader,width as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the thickness of the contour in 
the cel-�������.</A> <BR><A>Shader - Shader id</A> <BR><A>Width - the width.</A> 

<HR>
<A name=CelShaderSetOptions></A>
<H1 class=name>CelShaderSetOptions </H1><A class=type>Real</A><A> </A><A 
class=function>CelShaderSetOptions =</A><A>( shader,outlines,textured as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the cel-shader.</A> <BR><A>Shader 
- Shader id</A> <BR><A>Outlines - Specifies whether to draw the contours - 
</A><A class=constant>true</A><A> or </A><A class=constant>false</A><A> (1 and 0 
respectively)</A> <BR><A>Textured - Specifies whether to use the texture of the 
material - </A><A class=constant>true</A><A> or </A><A 
class=constant>false</A><A> (1 and 0, respectively).</A> 
<HR>
<A name=HiddenLineShaderCreate></A>
<H1 class=name>HiddenLineShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>HiddenLineShaderCreate =</A><A>();</A> <BR><A>Creates a shader 
hidden lines. The hidden line in this case, the edges of polygons that comprise 
objects. Usually they are not displayed, but the shader allows you to see 
them.</A> 
<HR>
<A name=HiddenLineShaderSetLineSmooth></A>
<H1 class=name>HiddenLineShaderSetLineSmooth </H1><A class=type>Real</A><A> 
</A><A class=function>HiddenLineShaderSetLineSmooth =</A><A>( shader,mode as 
</A><A class=type>real</A><A> );</A> <BR><A>Enables or disables the 
anti-aliasing lines (disabled by default).</A> <BR><A>Shader - Shader id</A> 
<BR><A>Mode - </A><A class=constant>true</A><A> or </A><A 
class=constant>false</A><A> (1 and 0, respectively).</A> 
<HR>
<A name=HiddenLineShaderSetSolid></A>
<H1 class=name>HiddenLineShaderSetSolid </H1><A class=type>Real</A><A> </A><A 
class=function>HiddenLineShaderSetSolid =</A><A>( shader,mode as </A><A 
class=type>real</A><A> );</A> <BR><A>Enables or disables the display of the 
material (disabled by default).</A> <BR><A>Shader - Shader id</A> <BR><A>Mode - 
</A><A class=constant>true</A><A> or </A><A class=constant>false</A><A> (1 and 
0, respectively).</A> 
<HR>
<A name=HiddenLineShaderSetSurfaceLit></A>
<H1 class=name>HiddenLineShaderSetSurfaceLit </H1><A class=type>Real</A><A> 
</A><A class=function>HiddenLineShaderSetSurfaceLit =</A><A>( shader,mode as 
</A><A class=type>real</A><A> );</A> <BR><A>Enables or disables the effect of 
light on material with a shader.</A> <BR><A>Shader - Shader id</A> <BR><A>Mode - 
</A><A class=constant>true</A><A> or </A><A class=constant>false</A><A> (1 and 
0, respectively).</A> 
<HR>
<A name=HiddenLineShaderSetFrontLine></A>
<H1 class=name>HiddenLineShaderSetFrontLine </H1><A class=type>Real</A><A> 
</A><A class=function>HiddenLineShaderSetFrontLine =</A><A>( 
shader,width,color,p,f as </A><A class=type>real</A><A> );</A> <BR><A>Sets the 
parameters of the front lines. Front lines are damaged, normal which turned in 
the direction of the observer.</A> <BR><A>Shader - Shader id</A> <BR><A>Width - 
the thickness of the</A> <BR><A>Color is the thickness of the</A> <BR><A>P - 
there are no information (the default 65535)</A> <BR><A>F - information about 
missing.</A> 
<HR>
<A name=HiddenLineShaderSetBackLine></A>
<H1 class=name>HiddenLineShaderSetBackLine </H1><A class=type>Real</A><A> </A><A 
class=function>HiddenLineShaderSetBackLine =</A><A>( shader,width,color,p,f as 
</A><A class=type>real</A><A> );</A> <BR><A>Sets the parameters of the rear 
lines. Rear lines are damaged, normal which turned in the opposite direction 
from the observer.</A> <BR><A>Shader - Shader id</A> <BR><A>Width - the 
thickness of the</A> <BR><A>Color is the thickness of the</A> <BR><A>P - there 
are no information (the default 65535)</A> <BR><A>F - information about 
missing.</A> 
<HR>
<A name=MultiMaterialShaderCreate></A>
<H1 class=name>MultiMaterialShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>MultiMaterialShaderCreate =</A><A>( matlib as </A><A 
class=type>real</A><A> );</A> <BR><A>Creates The ������������������ shader and 
returns its id. This shader allows you to create a material, consisting of 
several layers of other materials, with their own textures and parameters. These 
materials are loaded from a separate library. <BR>This extremely powerful shader 
is primarily useful for simulation of surfaces, consisting of several substances 
with different properties: for example, the wooden box, ��������� metal or stone 
interspersed with a lava or crystals. But it can be found, and other 
applications.</A> <BR><A>Matlib - id of the library materials. Materials will be 
imposed in the order in which they were added to the library (that is, the first 
material will be at the bottom).</A> 
<HR>
<A name=OutlineShaderCreate></A>
<H1 class=name>OutlineShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>OutlineShaderCreate =</A><A>( smooth as </A><A 
class=type>real</A><A> );</A> <BR><A>Creates a contour shader and returns its 
id. To be used for a simple multiplier effect - drawing contours around the 
object.</A> <BR><A>Smooth - information about missing.</A> 
<HR>
<A name=OutlineShaderSetLineColor></A>
<H1 class=name>OutlineShaderSetLineColor </H1><A class=type>Real</A><A> </A><A 
class=function>OutlineShaderSetLineColor =</A><A>( shader,color as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the color of the contour in the 
contour �������.</A> <BR><A>Shader - Shader id</A> <BR><A>Color - the color.</A> 

<HR>
<A name=OutlineShaderSetLineWidth></A>
<H1 class=name>OutlineShaderSetLineWidth </H1><A class=type>Real</A><A> </A><A 
class=function>OutlineShaderSetLineWidth =</A><A>( shader,width as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the thickness of the contour in 
the contour �������.</A> <BR><A>Shader - Shader id</A> <BR><A>Width - the 
width.</A> 
<HR>
<A name=TexCombineShaderCreate></A>
<H1 class=name>TexCombineShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>TexCombineShaderCreate =</A><A>( matlib as </A><A 
class=type>real</A><A> );</A> <BR><A>Creates a shader texture blending and 
returns its id. This shader allows you to program the simplest operations with 
the textures: summation, subtraction, multiplication, and so on. - It is 
something akin to the language of the description of shaders, which only works 
with textures. Shader supports up to 4 textures - the first two are set 
automatically (this is the first and the second the textures of the first 
material in the Library), the third and fourth are defined manually, the 
relevant functions.</A> <BR><A>Matlib - id of the library materials, which will 
be readable in the texture.</A> 
<HR>
<A name=TexCombineShaderMaterial3></A>
<H1 class=name>TexCombineShaderMaterial3 </H1><A class=type>Real</A><A> = </A><A 
class=function>TexCombineShaderMaterial3</A><A>( shader as </A><A 
class=type>real</A><A>, material as </A><A class=type>real</A><A> );</A> 
<BR><A>Specifies the material from which you want to read the third texture 
shader for combining the textures.</A> <BR><A>Shader - Shader id</A> <BR><A>The 
material is the name of the material.</A> 
<HR>
<A name=TexCombineShaderMaterial4></A>
<H1 class=name>TexCombineShaderMaterial4 </H1><A class=type>Real</A><A> = </A><A 
class=function>TexCombineShaderMaterial4</A><A>( shader as </A><A 
class=type>real</A><A>, material as </A><A class=type>real</A><A> );</A> 
<BR><A>Specifies the material from which you want to read the fourth texture 
shader for combining the textures.</A> <BR><A>Shader - Shader id</A> <BR><A>The 
material is the name of the material.</A> 
<HR>
<A name=TexCombineShaderAddCombiner></A>
<H1 class=name>TexCombineShaderAddCombiner </H1><A class=type>Real</A><A> </A><A 
class=function>TexCombineShaderAddCombiner =</A><A>( shader as </A><A 
class=type>real</A><A>, instruction as </A><A class=type>string</A><A> );</A> 
<BR><A>Adds a new ���������� - that is, the instructions for combining the 
textures. The syntax of the instruction recalls the operation of the assignment 
to Pascal. The four available symbols texture layers (Tex0, Tex1, Tex2, Tex3), 
to which you can add the suffixes ".A" and ".rgb for separately the alpha 
channel and the RGB values, respectively. Also supported are PrimaryColor 
identifier (or simply Col) - the main color of illumination (top), the functions 
of the Interpolate (Interpolation between the two textures) and Dot3 (the scalar 
product of textures).</A> <BR><A>The result of the shader ���������� with the 
highest index.</A> <BR><A>Shader - Shader id</A> <BR><A>Instruction - a string 
containing the instruction. Here are a few examples of the instructions:</A> 
<BR><A>"Tex1:=Tex0;" - the painting of the first texture</A> 
<BR><A>"Tex1:=Tex0+Tex1;" - summation of the first two textures</A> 
<BR><A>"Tex1:=Tex0-Tex1;" - the subtraction of the second texture from the 
first</A> <BR><A>"Tex1:=Tex0*Tex1;" - the multiplication of the first two 
textures</A> <BR><A>"Tex1:=Interpolate(Tex0,Tex1,PrimaryColor);" - the 
interpolation between the first two textures using light as a parameter (that 
is, the texture on the bright side will gradually move to the texture of the 
shadow side)</A> <BR><A>"Tex1:=Dot3(Tex0,Tex1); - the scalar product of the 
first two textures.</A> 
<HR>
<A name=PhongShaderCreate></A>
<H1 class=name>PhongShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>PhongShaderCreate =</A><A>( );</A> <BR><A>Creates The ����� 
shader that implements the pixelwise lighting with glare on the ������-����� 
(Blinn-Phong), and returns its id. <BR><A>This shader requires the support of 
the extensions of GL_ARB_shading_language (or GL_ARB_shading_language_100), 
GL_ARB_shader_objects, GL_ARB__vertex shader, GL_ARB_fragment_shader.</A> 
<HR>
<A name=PhongShaderUseTexture></A>
<H1 class=name>PhongShaderUseTexture </H1><A class=type>Real</A><A> </A><A 
class=function>PhongShaderUseTexture =</A><A>( shader,mode as </A><A 
class=type>real</A><A> );</A> <BR><A>Determines whether or not to take into 
account the texture in ������� �����. Used the texture of the material, 
connected to the shader (texture in slot 0). <BR>In addition to the color, 
texture also determines the transparency of the object, if it has an alpha 
channel. If this option is disabled, the job of transparency used the alpha 
value of the diffuse material components connected to the shader.</A> 
<BR><A>Shader - Shader id</A> <BR><A>Mode - </A><A class=constant>true</A><A> or 
</A><A class=constant>false</A><A> (1 and 0, respectively). By default, the 
texture is turned off.</A> 
<HR>
<A name=PhongShaderSetMaxLights></A>
<H1 class=name>PhongShaderSetMaxLights </H1><A class=type>Real</A><A> </A><A 
class=function>PhongShaderSetMaxLights =</A><A>( shader,maxlights as </A><A 
class=type>real</A><A> );</A> <BR><A>Specifies the number of light sources, 
which should take into account The ����� shader. This number, as a rule, is less 
than or equal to the number of light sources created by the function of the 
</A><A class=funclink 
href="../functions/light.htm#LightCreate">LightCreate</A><A>. Accordingly, it is 
limited to eight - the maximum number of built-in light sources OpenGL. Shader 
supports all types of light sources: </A><A class=constant>lsOmni</A><A>, </A><A 
class=constant>lsSpot</A><A>, </A><A class=constant>lsParallel</A><A>. <BR>Note 
also that the condition of the inclusion/������������� light sources, which is 
selected by the function of the </A><A class=funclink 
href="../functions/light.htm#LightSetShining">LightSetShining</A><A>ignores the 
shader. To turn off the light source that can </A><A class=funclink 
href="../functions/light.htm#LightSetAttenuation"></A><A>adjust 
LightSetAttenuation to zero his constant component of the attenuation constant 
attenuation). </A><BR><A>Shader - Shader id</A> <BR><A>Maxlights - the number of 
light sources. The default value is: 1.</A> 
<HR>
<A name=GLSLShaderCreate></A>
<H1 class=name>GLSLShaderCreate </H1><A class=type>Real</A><A> </A><A 
class=function>GLSLShaderCreate =</A><A>( vertexshader,fragmentshader as </A><A 
class=type>string</A><A> );</A> <BR><A>Creates a GLSL shader and returns its id. 
GLSL (OpenGL Shading Language) is a language of the description of shaders, 
using which you can program the graphics pipeline (in other words, to manage the 
rendering of objects on the ��������� and pixel level). For the processing of 
peaks is responsible ��������� program, for processing pixels - �����������.</A> 
<BR><A>This shader requires the support of the extensions of 
GL_ARB_shading_language (or GL_ARB_shading_language_100), GL_ARB_shader_objects, 
GL_ARB__vertex shader, GL_ARB_fragment_shader.</A> <BR><A>Vertexshader - a 
string containing the ��������� GLSL program (not the name of the file!)</A> 
<BR><A>Fragmentshader - a string containing the ����������� GLSL program (not 
the name of the file!)</A> <BR><A>If the function would be transferred to the 
incorrect program that will display the error message, and the engine will 
continue to operate.</A> 
<HR>
<A name=GLSLShaderCreateParameter></A>
<H1 class=name>GLSLShaderCreateParameter </H1><A class=type>Real</A><A> </A><A 
class=function>GLSLShaderCreateParameter =</A><A>( shader as </A><A 
class=type>real</A><A>, name as </A><A class=type>real</A><A> );</A> 
<BR><A>Creates a new shader parameter and returns its id. These parameters 
correspond to the uniform-variable GLSL. They can be modified dynamically in 
your game, but in the ������� they are read-only.</A> <BR><A>Shader - Shader 
id</A> <BR><A>Name - the name of the parameter.</A> 
<HR>
<A name=GLSLShaderSetParameter1i></A>
<H1 class=name>GLSLShaderSetParameter1i </H1><A class=type>Real</A><A> = </A><A 
class=function>GLSLShaderSetParameter1i</A><A>( param,value as </A><A 
class=type>real</A><A> );</A> <BR><A>Sends the value parameter of type int 
(integer).</A> <BR><A>Param parameter id</A> <BR><A>Value is the value.</A> 
<HR>
<A name=GLSLShaderSetParameter1f></A>
<H1 class=name>GLSLShaderSetParameter1f </H1><A class=type>Real</A><A> = </A><A 
class=function>GLSLShaderSetParameter1f</A><A>( param,value as </A><A 
class=type>real</A><A> );</A> <BR><A>Sends a parameter value of type float (a 
real number).</A> <BR><A>Param parameter id</A> <BR><A>Value is the value.</A> 
<HR>
<A name=GLSLShaderSetParameter2f></A>
<H1 class=name>GLSLShaderSetParameter2f </H1><A class=type>Real</A><A> = </A><A 
class=function>GLSLShaderSetParameter2f</A><A>( param,x,y as </A><A 
class=type>real</A><A> );</A> <BR><A>Sends the value parameter vec type2 (vector 
of two real numbers).</A> <BR><A>Param parameter id</A> <BR><A>X,Y is the 
vector.</A> 
<HR>
<A name=GLSLShaderSetParameter3f></A>
<H1 class=name>GLSLShaderSetParameter3f </H1><A class=type>Real</A><A> = </A><A 
class=function>GLSLShaderSetParameter3f</A><A>( param,x,y,z as </A><A 
class=type>real</A><A> );</A> <BR><A>Sends the value parameter vec type3 (vector 
of three real numbers).</A> <BR><A>Param parameter id</A> <BR><A>X,y,z - 
vector.</A> 
<HR>
<A name=GLSLShaderSetParameter4f></A>
<H1 class=name>GLSLShaderSetParameter4f </H1><A class=type>Real</A><A> = </A><A 
class=function>GLSLShaderSetParameter4f</A><A>( param,x,y,z,w as </A><A 
class=type>real</A><A> );</A> <BR><A>Sends the value parameter vec type4 (vector 
of four real numbers).</A> <BR><A>Param parameter id</A> <BR><A>X,y,z,w is the 
vector.</A> 
<HR>
<A name=GLSLShaderSetParameterTexture></A>
<H1 class=name>GLSLShaderSetParameterTexture </H1><A class=type>Real</A><A> 
</A><A class=function>GLSLShaderSetParameterTexture =</A><A>( param as </A><A 
class=type>real</A><A>, material as </A><A class=type>string</A><A>, The texunit 
as </A><A class=type>real</A><A> );</A> <BR><A>Transmits to the texture of the 
specified material. The type of texture (sampler2D, The samplerCube and etc.) is 
installed automatically.</A> <BR><A>Param parameter id</A> <BR><A>The material 
is the name of the material (in the active library materials). If instead of the 
name specified the empty string, it will be used by the texture of the material, 
connected to the shader (texture in the slot with the index of texunit). Thus, 
one and the same shader can work with different textures depending on the 
material that, in some situations, it is very convenient.</A> <BR><A>Texunit - 
determines which texture unit to transmit texture. The OpenGL standard 
guarantees 8 available texture units (0-7) - the modern video cards they can be 
and more (up to 16 or even 32), but for the best compatibility it is better not 
to use more than 8. The automatic use of textures of material (see explanation 
to the previous argument), the number of the texture corresponds to the slot you 
����������� material, and their number is also equal to 8. In one ������� cannot 
transmit two different textures through one and the same texture unit.</A> 
<HR>
<A name=GLSLShaderSetParameterSecondTexture></A>
<H1 class=name>GLSLShaderSetParameterSecondTexture </H1><A 
class=type>Real</A><A> </A><A class=function>GLSLShaderSetParameterSecondTexture 
=</A><A>( param as </A><A class=type>real</A><A>, material as </A><A 
class=type>string</A><A>, The texunit as </A><A class=type>real</A><A> );</A> 
<BR><A>Transmits to the second texture of the specified material. The type of 
texture (sampler2D, The samplerCube and etc.) is installed automatically.</A> 
<BR><A>Param parameter id</A> <BR><A>The material is the name of the material 
(in the active library materials). If instead of the name specified the empty 
string, it will be used by the second texture of the material, connected to the 
shader.</A> <BR><A>Texunit - determines which texture unit to transmit 
texture.</A> 
<HR>
<A name=GLSLShaderSetParameterHasTextureEx></A>
<H1 class=name>GLSLShaderSetParameterHasTextureEx </H1><A class=type>Real</A><A> 
</A><A class=function>GLSLShaderSetParameterHasTextureEx =</A><A>( param,index 
as </A><A class=type>real</A><A> );</A> <BR><A>Sends a parameter (int or bool) 
unit, if the material, connected to the shader, there is the texture in the 
specified ���������� block, and zero otherwise.</A> <BR><A>Param parameter 
id</A> <BR><A>Index - the index of the slot texture (from 0 to 7 inclusive).</A> 

<HR>
<A name=GLSLShaderSetParameterMatrix></A>
<H1 class=name>GLSLShaderSetParameterMatrix </H1><A class=type>Real</A><A> 
</A><A class=function>GLSLShaderSetParameterMatrix =</A><A>( param,object as 
</A><A class=type>real</A><A> );</A> <BR><A>Sends a parameter the absolute 
transformation matrix of the specified object (a type of mat4).</A> <BR><A>Param 
parameter id</A> <BR><A>The object is the object ID.</A> 
<HR>
<A name=GLSLShaderSetParameterInvMatrix></A>
<H1 class=name>GLSLShaderSetParameterInvMatrix </H1><A class=type>Real</A><A> 
</A><A class=function>GLSLShaderSetParameterInvMatrix =</A><A>( param,object as 
</A><A class=type>real</A><A> );</A> <BR><A>Sends a return parameter the 
absolute transformation matrix of the specified object (a type of mat4).</A> 
<BR><A>Param parameter id</A> <BR><A>The object is the object ID.</A> 
<HR>
<A name=GLSLShaderSetParameterViewMatrix></A>
<H1 class=name>GLSLShaderSetParameterViewMatrix </H1><A class=type>Real</A><A> 
</A><A class=function>GLSLShaderSetParameterViewMatrix =</A><A>( param as </A><A 
class=type>real</A><A> );</A> <BR><A>Sends a parameter current ������� matrix 
(mat type4), which transports the point and vectors in the world's space in the 
species, where the beginning of the coordinates is the position of the camera, 
through which takes place rendering. The parameter is automatically updated when 
the transformation of the camera.</A> <BR><A>Param is the id parameter.</A> 
<HR>
<A name=GLSLShaderSetParameterInvViewMatrix></A>
<H1 class=name>GLSLShaderSetParameterInvViewMatrix </H1><A 
class=type>Real</A><A> </A><A class=function>GLSLShaderSetParameterInvViewMatrix 
=</A><A>( param as </A><A class=type>real</A><A> );</A> <BR><A>Sends a parameter 
current feedback ������� matrix (mat type4), which transports the point and 
vectors of the species space in the world. The parameter is automatically 
updated when the transformation of the camera.</A> <BR><A>Param is the id 
parameter.</A> 
<HR>
<A name=GLSLShaderSetParameterShadowTexture></A>
<H1 class=name>GLSLShaderSetParameterShadowTexture </H1><A 
class=type>Real</A><A> </A><A class=function>GLSLShaderSetParameterShadowTexture 
=</A><A>( param,shadowmap,texunit as </A><A class=type>real</A><A> );</A> 
<BR><A>Sends the parameter buffer texture of the shadow map. In the GLSL it has 
the type of sampler2DShadow. With the help of this texture can be realized in 
the ������� rendering of shadows.</A> <BR><A>Param parameter id</A> 
<BR><A>Shadowmap - id of the shadow maps</A> <BR><A>Texunit - determines which 
texture unit to transmit texture.</A> 
<HR>
<A name=GLSLShaderSetParameterShadowMatrix></A>
<H1 class=name>GLSLShaderSetParameterShadowMatrix </H1><A class=type>Real</A><A> 
</A><A class=function>GLSLShaderSetParameterShadowMatrix =</A><A>( 
param,shadowmap as </A><A class=type>real</A><A> );</A> <BR><A>Sends the shadow 
parameter a matrix from the shadow map (mat type4). This matrix shows The 
�������� vectors-species space into the amputation of the shadow buffer.</A> 
<BR><A>Param parameter id</A> <BR><A>The object is the object ID.</A> 
<HR>
<A name=GLSLShaderSetParameterFBOColorTexture></A>
<H1 class=name>GLSLShaderSetParameterFBOColorTexture </H1><A 
class=type>Real</A><A> </A><A 
class=function>GLSLShaderSetParameterFBOColorTexture =</A><A>( param,fbo 
texunit,as </A><A class=type>real</A><A> );</A> <BR><A>Sends the parameter color 
texture FBO buffer.</A> <BR><A>Param parameter id</A> <BR><A>Fbo - FBO id</A> 
<BR><A>Texunit - determines which texture unit to transmit texture.</A> 
<HR>
<A name=GLSLShaderSetParameterFBODepthTexture></A>
<H1 class=name>GLSLShaderSetParameterFBODepthTexture </H1><A 
class=type>Real</A><A> </A><A 
class=function>GLSLShaderSetParameterFBODepthTexture =</A><A>( param,fbo 
texunit,as </A><A class=type>real</A><A> );</A> <BR><A>Transmits to the texture 
of the Z-buffer FBO.</A> <BR><A>Param parameter id</A> <BR><A>Fbo - FBO id</A> 
<BR><A>Texunit - determines which texture unit to transmit texture.</A> 
<HR>
</DIV></BODY></HTML>
