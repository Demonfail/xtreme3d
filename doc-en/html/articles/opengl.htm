<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=us-ascii">
<TITLE>OpenGL</TITLE>
<LINK href="../data/style.css" type="text/css" rel="stylesheet">
</HEAD>
<BODY>

<DIV ALIGN=justify>

<H1 class=pagetitle>OpenGL</H1>
<A>OpenGL (Open Graphics Library) is a specification that defines a cross-platform API for creating applications utilizing 2D and 3D computer graphics. OpenGL includes functions for rendering complex 3D scenes using simple primitives. It is used in computer games, CAD, virtual reality, scientific and industrial visualization. Under Windows OpenGL competes with Direct3D.
<br>
<br><B>Specification</B>
<br>At the basic level, OpenGL is simply a specification, that is, a document that describes a set of functions and their exact behavior. Based on this specification hardware manufacturers usually create an implementation - a development library. To accelerate graphics processing, OpenGL is designed to use specialized graphics hardware (GPU) as much as possible. If GPU does not support some feature, it can be emulated programmatically. Any particular OpenGL implementation must pass specific conformance tests before it officially sertified. Thus, graphics applications should only follow conventions provided in the specification, leaving effective implementation to a system-level driver.
<br>Nowadays effective OpenGL implementations exist for all common platforms and operating systems, including Windows, Unix (Linux, BSD, macOS), PlayStation 3, Android, etc. These implementations are typically provided by GPU manufacturers. There are also 'non-official' OpenGL implementations - most notably, Mesa. It does not have a certification, although it is fully standard-compliant and supports hardware acceleration.
<br>Authors of the original specification are Kurt Akeley and Mark Segal. Version 1.1 was edited by Chris Frazier, versions 1.2 to 2.0 - by Jon Leech.
<br>
<br><B>Architecture</B>
<br>OpenGL is focused on two tasks:
<br>- hide complexity of 3D accelerators, providing developers with a simple API;
<BR>- hide differences of hardware platforms, compensating missing functions with software emulation.
<br>The basic principle of OpenGL is obtaining sets of vector primitives (points, lines and polygons), processing and rasterizing them. Vector  transformations and rasterization are done by the graphics pipeline, which is a discrete automata. An absolute majority of OpenGL functions fall into one of two groups: either they add vector primitives to the pipeline's input, or configure the pipeline to do different transformations.
<br>OpenGL is a low-level procedural API which forces the programmer to define exact sequence of steps to synthezise the resulting image. This is called an imperative approach. It is principally different from declarative approach, when the entire 3D scene is stored as a data structure (usually a tree), which
is processed and rendered by a graphics library. Imperative approach requires the programmer to have deep knowledge of 3D graphics and its mathematical models. On the other hand, it provides freedom for various innovations.
<br>
<br><B>Extensions</B>
<br>OpenGL allows implementers to improve its functionality through extensions mechanism. Extensions consists both of API specification (new functions and constants) and its implementation which is part of OpenGL library. Each manufacturer has abbreviation that is used in extension names. For example, NVIDIA has 'NV' abbreviation (GL_NORMAL_MAP_NV, etc). It may happen that some extension can be implemented by several manufacturers. In this case, it is abbreviated with 'EXT' - for example, GL_EXT_framebuffer_object. In case if extension is approved by the OpenGL Consortium, it is marked with 'ARB' abbreviation and becomes the standard extension. Usually standard extensions are then included in one of the subsequent versions of OpenGL specification. OpenGL applications can check if a particular extension is available on a target system and, if so, use it, thus utilizing cutting-edge graphics technologies.
<br>
<br><B>Additional libraries</B>
<br>There are a number of libraries, created on top of or in addition to OpenGL. For example, GLU, which was virtually the standard complementation library before OpenGL 3.0. GLU uses OpenGL functions to implement its own ones (drawing 3D shapes, loading textures, extended transformation functions and others). Other libraries, such as GLUT and SDL, provide features that are not available in OpenGL. They include window creation, event handling, user input processing. Typically, each window manager has its own extension library that implement these features - for example, WGL under Windows or GLX under X Window System. However, GLUT and SDL are cross-platform libraries that make easy porting graphics applications between operating systems. Such libraries as GLEW and GLEE are created in order to facilitate work with OpenGL extensions and different versions of OpenGL itself.

<br>OpenGL supports only a set of geometric primitives (points, lines, and polygons) which are used to render all 3D objects. This level of abstraction is not always convenient when creating 3D graphics applications. Therefore more high-level libraries were created on top of OpenGL, such as Open Inventor, VTK, OpenSceneGraph, and GLScene. These libraries allow programmer to operate with more abstract concepts (such as models, materials, animations) which simplifies and accelerates 3D scene creation. Such libraries often created as parts of game engines, so that programmers can focus on gameplay rather than graphics pipeline.
<br>
<br><B>Language independence</B>
<br>OpenGL can be used with almost any popular programming language. Since OpenGL specification is based on standard C ABI, it is possible to acess it from any language that supports C calling convention and has C-compatible type system (or allows to write native extensions in C, like Python does). Nowadays OpenGL support exists for C, Java, C#, Python, Perl, Ruby, Lisp, Pascal, Visual Basic, D, Rust, Go and numerous other languages.
<br>
<br><B>History</B>
<br>Computer graphics is widely used in everyday life. Scientists use it for analysis of simulation results. Engineers, designers and architects use it to create virtual models of their products. Filmmakers create amazing special effects for movies and animations. Computer games would not even exist without computer graphics, and nowadays they heavily depend on the most advanced graphics technologies to create breathtaking virtual worlds.
<br>
<br>But 30 years ago it wasn't so. Development of a software product capable to work on a wide range of hardware has been difficult, time-consuming and costly. It was necessary to create separate modules for each type of graphics adapters, which sometimes led to large source code duplication. This strongly slowed down development and spreading of computer graphics.
<br>
<br>OpenGL history began in 1982, when Stanford University developed a concept of a graphics machine, which then was implemented by famous Silicon Graphics Inc. on their Silicon IRIS workstation. SGI specialized in creating high-tech graphics hardware and software and was the leader in 3D graphics at that time. As a leader, it increasingly confronted with barriers to the market growth, caused mainly by large temporal and financial costs of developing programs that were able to work on different graphics hardware. 
It was therefore decided to standardize access to graphics hardware at software interface level. So IRIS GL graphics library was designed, which became the predeccessor of OpenGL. 
One of IRIS GL limitations was that it allowed to use only the features supported by the hardware. If the feature was not implemented in hardware, the application could not use it. In 1992 OpenGL was developed on the basis of IRIS GL, and it was approved as the graphics standard. The problem of its predecessor overcame at the expense of the software emulation of features that were not supported by the hardware. This allowed applications
to use this interface even at low-end systems.
<br>
<br>At the same time, consortium of companies that support the new standard was created, which were called ARB (Architecture Review Board). For many years it determined development of OpenGL, revising its specification. Alongside SGI it united a lot of large corporations such as IBM, Sun Microsystems, Digital Equipment Corporation, Evans & Sutherland, Hewlett-Packard, Intel and Intergraph. Even Microsoft has made a hand to the new graphical standard - the same Microsoft which a few years later, in 1995, will release the first version of DirectX, the future competitor of OpenGL. Microsoft withdrew from the ARB in 2003, but now the consortium contains all major GPU manufacturers including AMD and NVIDIA.
<br>
<br>Initially created for professional sector, OpenGL established in there very firmly. It was used in high-performance industrial workstations, science, education, as well as in projects where application portability between various software or hardware platforms were required. By the time ARB drew attention to the rapidly developing gaming industry, it turned out that OpenGL had serious competitors. In the game graphics accelerators market, 3DFX was a leader, which in 1994 created Glide, the first full-fledged game graphics API. Of course, it supported only chipsets produced by 3DFX itself, which allowed it for a few years to become almost a monopoly in gaming 3D graphics market. But closed API played with 3DFX a cruel trick. When OpenGL came to the gaming market in 1996, it was greeted with open arms by developers.
<br>
<br>In the meantime, OpenGL acquired another rival - Microsoft corporation took up the development of its own proprietary graphics API. In 1995, the company released the first version of DirectX, at the time called Games SDK, running only under Windows 95. A native OpenGL driver for Windows also existed, but it worked much worse and slower than Direct3D. This was done, of course, with an eye to the fact that game developers will work with Direct3D, and not with 'less effective' OpenGL. At first it was so, but soon Silicon Graphics developed its own OpenGL ICD (Installable Client Driver), and then many GPU manufacturers began to include their OpenGL implementations into driver packages, which made possible to use graphics cards most efficiently. In addition, manufacturers could freely add new functions to their ICDs. 
<br>
<br>Feeling that it were losing control, Microsoft decided to stop the war of standards and suggested SGI to develop a common API. The project was called Fahrenheit, and the work began. Microsoft demanded to remove all references to SGI's implementation of OpenGL from the Internet, and to stop its further support, which was done. Alas, Fahrenheit was not destined to be born. Microsoft, pursuing its benefits, decided to implement the new API only through Direct3D, and the cooperation did not work out. SGI was responsible for the OpenGL part of the project, but the company was going through hard times, the specialists were leaving to NVIDIA, so SGI did not have enthusiasm. So would OpenGL have died quietly and imperceptibly, if only it haven't received a strong support from John Carmack and id Software. OpenGL was chosen as the graphical library for the famous Quake, which was the salvation for the former. The game was a great success, modifications and ports began to appear soon. Quake's graphics engine has become popular, appeared games that were using it, and, consequently, using OpenGL. The standard survived, and the big race continued.
<br>
<br>It was thought that the main problem of OpenGL, compared to DirectX, was a Consortium of a large number of companies with different interests, which led to a long period of new specification versions adoption. OpenGL version 2.0 was presented by 3DLabs in response to concerns about the slow development and unclear direction of OpenGL. 3DLabs proposed a number of significant additions to the standard, the most significant of them being inclusion of OpenGL Shading Language (GLSL) to the core specification. It allows the programmer to replace the fixed pipeline with small programs written in special high-level language to create various effects, such as bump mapping, paralax mapping, HDR, etc. Interestingly, even before that there was a possibility to develop special effects in assembly language (with GL_ARG_vertex_program and GL_ARB_fragment_program extensions) and Cg language (C for graphics) from NVIDIA.
<br>
<br>The Consortium itself, which determines direction of OpenGL development, many times changed its composition, and now includes AMD, Apple, Creative Labs, Intel, id Software, NVIDIA, Sony Computer Entertainment, Sun Microsystems and Texas Instruments.
<br>
<br>In 2008, the Khronos Group released OpenGL 3.0 that included support for GLSL 1.3, Vertex Array Objects, texture arrays, more flexible FBOs and a number of other features. Year later, OpenGL 3.1 was announced. This new version featured a huge API redesign and cleanup. A lot of components 
that were declared deprecated but still remained in OpenGL 3.0 for smooth migration, were removed in 3.1. In addition, OpenGL 3.1 introduced a number of innovations, such GLSL 1.4, texture buffer objects, and so on. In the same year OpenGL 3.2 was announced with GLSL 1.50 and geometry shaders support.
<br>
<br>In 2010 Consortium approved OpenGL 4.0. Among the new features it included integration with OpenCL (Open Computing Language), multi-threaded rendering, GLSL 4.0, support for 64-bit floating point type, as well as numerous performance improvements. At the same time OpenGL 3.3 was released to backport some functionality of top GPUs to 3.x level hardware (this included dual-source blending, shader-defined attribute locations and some new GLSL functions).
<br>
<br>OpenGL 4.1, released also in 2010, included GLSL 4.10, as well as support for saving and loading compiled binaries of shader programs.
<br>
<br>In 2011, the Khronos Group presented OpenGL 4.2 and GLSL 4.20.
<br>
<br>In 2012, the Khronos Group celebrated the 20-th anniversary of OpenGL presenting vesion 4.3 of the specification. This version introduced compute
shaders that allow using GPU for non-graphical computations, as well as the buffer data objects that can be passed between shaders.
<br>
<br>In 2013, OpenGL 4.4 was released. This version included tools for working video memory, asynchrony, as well as tools to simplify porting Direct3D 11 applications.
<br>
<br>OpenGL 4.5, released in 2014, supports a new method of state access, allowing queries and state changes without binding objects to the context.
<br>
<br>In 2017, OpenGL 4.6 was released. Main new feature was SPIR-V support, a portable intermediate representation of shaders originating from Vulkan API, as well as anisotropic texture filtering.
<br>
<br>Big race has continued for more than 20 years, and it is unknown how long it will last. But OpenGL, despite the fact that it constantly lags behind Direct3D for a half-step, obstinately doesn't exit the scene. And won't, if only a qualitative leap won't occur, the same as OpenGL itself was at its time. Even the emergence of Vulkan haven't affected its popularity. The openness, portability, extendability, and programming language independence - these are what keep OpenGL afloat all these years.
</a>
<br>
<br><A class=link href="../links.htm#OpenGL">Links related to this article</a>
</DIV>

</BODY>
</HTML>
