<HTML>
<HEAD>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<TITLE>FBO</TITLE>
<LINK href="../data/style.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>

<DIV ALIGN=justify>

<H1 class=pagetitle>FBO</H1>

<A class=type>Класс: TGLFBO</A><BR><BR>

<A>FBO (Frame Buffer Object) - это современный механизм внеэкранного рендеринга, пришедший на смену p-буферам (см. 
<A class=link href="memviewer.htm">MemoryViewer</A>). Как и MemoryViewer, FBO позволяет рендерить сцену в отдельный буфер в видеопамяти, содержимое которого затем становится доступным в качестве текстуры. Это позволяет производить над полученным изображением различные шейдерные операции постобработки, применять фильтры и спецэффекты.
<BR/>В отличие от MemoryViewer, FBO не требует относительно дорогостоящей операции переключения контекстов OpenGL, поэтому на современных системах предпочтительнее использовать именно его. Также FBO работает намного быстрее, чем 
</A><A class=funclink href=../functions/viewer.htm#ViewerCopyToTexture>ViewerCopyToTexture</A><A>, 
которая, фактически, совершает копирование данных из одного буфера в другой. Еще одно преимущество - FBO предоставляет полноценный доступ к Z-буферу, что необходимо для реализации некоторых фильтров. При этом пользоваться FBO ничуть не сложнее, чем MemoryViewer. Единственное ограничение состоит в том, что доступ к текстурам FBO возможен только через шейдеры GLSL - то есть, нельзя создать материал, который бы использовал FBO-текстуру без шейдера.
<BR/>Чтобы передать текстуры FBO в GLSL-шейдер, используйте функции 
</A><A class=funclink href=../functions/shader.htm#GLSLShaderSetParameterFBOColorTexture>GLSLShaderSetParameterFBOColorTexture</A><A> и 
</A><A class=funclink href=../functions/shader.htm#GLSLShaderSetParameterFBODepthTexture>GLSLShaderSetParameterFBODepthTexture</A><A> - 
соответственно, для цветового буфера и Z-буфера.
</A>
<HR>

<A name="FBOCreate"></A>
<H1 class=name>FBOCreate</H1>
<A class=type>real</A><A> = </A><A class=function>FBOCreate</A><A>( width,height,viewer as </A><A class=type>real</A><A> );</A>
<BR><A>Создает новый FBO и возвращает его id.</A>
<BR><A>width,height - ширина и высота буфера</A>
<BR><A>viewer - id вида, настройки которого нужно использовать для рендеринга (фоновой цвет, туман, соотношение сторон и т.д.).</A>
<HR>

<A name="FBOSetCamera"></A>
<H1 class=name>FBOSetCamera</H1>
<A class=type>real</A><A> = </A><A class=function>FBOSetCamera</A><A>( fbo,camera as </A><A class=type>real</A><A> );</A>
<BR><A>Задает камеру, через которую FBO должен рендерить сцену.</A>
<BR><A>fbo - id FBO</A>
<BR><A>camera - id камеры.</A>
<HR>

<A name="FBOSetViewer"></A>
<H1 class=name>FBOSetViewer</H1>
<A class=type>real</A><A> = </A><A class=function>FBOSetViewer</A><A>( fbo,viewer as </A><A class=type>real</A><A> );</A>
<BR><A>Задает вид, настройки которого нужно использовать для рендеринга (фоновой цвет, туман, соотношение сторон и т.д.).</A>
<BR><A>fbo - id FBO</A>
<BR><A>view - id вида.</A>
<HR>

<A name="FBORenderObject"></A>
<H1 class=name>FBORenderObject</H1>
<A class=type>real</A><A> = </A><A class=function>FBORenderObject</A><A>( fbo,object as </A><A class=type>real</A><A> );</A>
<BR><A>Совершает рендеринг объекта в FBO. Обратите внимание, что читать текстуры FBO во время рендеринга в него не рекомендуется, это приведет к неопределенному результату. Иными словами, избегайте ситуации, когда в FBO рендерится объект, использующий шейдер, который читает текстуру того же FBO.</A>
<BR><A>fbo - id FBO</A>
<BR><A>object - объект, который нужно отрендерить (вместе с его потомками). Как правило, в этот параметр передается Dummycube, содержащий иерархию 3D-сцены.</A>
<HR>

</DIV>

</BODY>
</HTML>
